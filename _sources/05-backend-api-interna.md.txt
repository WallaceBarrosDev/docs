# 5. Integra√ß√£o do Back-End com a API Interna

## 7.1 Explica√ß√£o n√£o t√©cnica

A **API Interna** √© a ‚Äúporta oficial‚Äù pela qual o front-end conversa com o backend.  
Ela:

* Recebe as requisi√ß√µes do front-end (ex.: listar dados, salvar formul√°rio).
* Garante que **todas** as regras de seguran√ßa e valida√ß√£o sejam aplicadas.
* Encaminha o pedido para a **l√≥gica de neg√≥cio** correta (servi√ßos/casos de uso).
* Junta dados do **banco interno**, do **sistema local/externo** e do **cache**.
* Devolve uma **resposta padronizada em JSON**, simples de consumir pelo front-end.

Para o front-end, a API Interna √© um **ponto √∫nico e est√°vel**: ele n√£o precisa conhecer detalhes de banco, APIs locais, formatos legados, etc.

---

## 7.2 Fluxo de Requisi√ß√£o via API Interna

O diagrama abaixo mostra como a API Interna integra o front-end com o backend:

```{mermaid}
sequenceDiagram
    participant FE as üåê Frontend
    participant API as üîß API Interna
    participant MW as üß± Middlewares
    participant SVC as üß† Servi√ßo de Dom√≠nio
    participant DBI as üóÑÔ∏è DB Interno
    participant EXT as üß© API Local

    FE->>API: HTTP request (JSON)
    API->>MW: Encaminha requisi√ß√£o
    MW->>MW: Valida, autentica, loga
    MW->>SVC: Chama caso de uso

    SVC->>DBI: Consulta/atualiza dados internos
    DBI-->>SVC: Retorno interno

    SVC->>EXT: (Opcional) chama API Local
    EXT-->>SVC: Retorno externo

    SVC-->>API: Resultado agregado
    API-->>FE: HTTP response (JSON)
```

Resumo do fluxo:

    O Frontend envia uma requisi√ß√£o HTTP para a API Interna.
    A API passa pelos middlewares (auth, logs, valida√ß√£o b√°sica).
    Os servi√ßos de dom√≠nio executam a regra de neg√≥cio, acessando:
        Banco interno (DB Interno),
        API Local (que conversa com o DB Externo),
        Cache (quando aplic√°vel, ver se√ß√£o 3 e 6).
    Os dados s√£o tratados e unificados.
    A resposta volta em um formato JSON padronizado para o frontend.

## 7.3 Contratos e Padr√µes da API Interna

Base path √∫nico para a API, por exemplo: /api.
Versionamento por prefixo, quando necess√°rio:

    /api/v1/...
    /api/v2/... (quando houver quebra de compatibilidade).

Os nomes de recursos seguem um padr√£o REST simples:

    GET /api/v1/items
    POST /api/v1/items
    GET /api/v1/items/:id

7.3.2 Formato de Resposta

Todas as respostas da API Interna seguem um formato consistente (exemplo):

```json
{
  "data": {
    "id": 123,
    "nome": "Exemplo",
    "ativo": true
  },
  "meta": {
    "timestamp": "2025-01-01T12:00:00Z",
    "correlationId": "abc-123"
  },
  "errors": []
}
```

7.3.3 Tratamento de Erros

Erros s√£o sempre devolvidos de forma estruturada, por exemplo:

```json
{
  "data": null,
  "meta": {
    "timestamp": "2025-01-01T12:00:00Z",
    "correlationId": "abc-123"
  },
  "errors": [
    {
      "code": "VALIDATION_ERROR",
      "message": "Campo 'nome' √© obrigat√≥rio",
      "field": "nome"
    }
  ]
}
```

C√≥digos de erro padronizados (ex.: UNAUTHORIZED, FORBIDDEN, NOT_FOUND, VALIDATION_ERROR, INTERNAL_ERROR).
Status HTTP coerentes:

    200/201 para sucesso,
    400 para erro de valida√ß√£o,
    401/403 para falhas de autentica√ß√£o/autoriza√ß√£o,
    404 para recurso n√£o encontrado,
    500 para erro interno inesperado.

## 7.4 Seguran√ßa e Autentica√ß√£o na API Interna

Toda requisi√ß√£o relevante passa por middlewares de seguran√ßa:

    Valida√ß√£o de token (ex.: JWT, sess√£o ou outro mecanismo configurado).
    Verifica√ß√£o de permiss√µes (roles, escopos, perfis).

O frontend nunca fala diretamente com o sistema externo:

    Tokens e credenciais sens√≠veis ficam apenas no backend.
    A API Interna atua como camada de prote√ß√£o e ‚Äútradutor‚Äù entre o front e o legado.

Logs estruturados registram:

    correlationId (para rastrear a requisi√ß√£o ponta a ponta),
    usu√°rio autenticado (quando houver),
    endpoint, status HTTP e tempo de resposta.

## 7.5 Decis√µes Essenciais de Integra√ß√£o

üåê Ponto √∫nico de entrada: todo consumo do front passa pela API Interna.

üìè Contratos est√°veis: mudan√ßas internas no backend n√£o quebram o front, desde que o contrato da API se mantenha.

üß± Middlewares obrigat√≥rios: autentica√ß√£o, autoriza√ß√£o, logs e valida√ß√£o sempre antes da l√≥gica de neg√≥cio.

üîÑ Tratamento uniforme de erros: o front lida com um formato √∫nico de erro, independentemente da origem (DB Interno, API Local, etc.).

üß© Encapsulamento do legado: o DataBridge e os clientes externos escondem peculiaridades da API Local e do DB Externo.

üìë Documenta√ß√£o da API: endpoints documentados em formato adequado (OpenAPI/Swagger ou equivalente), alinhados com esta se√ß√£o.
